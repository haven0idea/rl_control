"""LCM type definitions
This file automatically generated by lcm.
DO NOT MODIFY BY HAND!!!!
"""


from io import BytesIO
import struct

class control_cmd_lcmt(object):

    __slots__ = ["action_type", "action_num", "action_position", "action_velocity", "action_acceleration", "action_torque"]

    __typenames__ = ["byte", "int32_t", "float", "float", "float", "float"]

    __dimensions__ = [None, None, ["action_num"], ["action_num"], ["action_num"], ["action_num"]]

    def __init__(self):
        self.action_type = 0
        """ LCM Type: byte """
        self.action_num = 0
        """
        0000 | pvat; for the lower 4 bits, once it's been set
        the corresponding type of the cmd is active
        Example: 8(1000) for position only, 12(1100) for position
        and velocity.
        LCM Type: int32_t
        """

        self.action_position = []
        """
        motor number
        LCM Type: float[action_num]
        """

        self.action_velocity = []
        """
        position cmd
        LCM Type: float[action_num]
        """

        self.action_acceleration = []
        """
        velocity cmd
        LCM Type: float[action_num]
        """

        self.action_torque = []
        """
        acceleration cmd
        LCM Type: float[action_num]
        """


    def encode(self):
        buf = BytesIO()
        buf.write(control_cmd_lcmt._get_packed_fingerprint())
        self._encode_one(buf)
        return buf.getvalue()

    def _encode_one(self, buf):
        buf.write(struct.pack(">Bi", self.action_type, self.action_num))
        buf.write(struct.pack('>%df' % self.action_num, *self.action_position[:self.action_num]))
        buf.write(struct.pack('>%df' % self.action_num, *self.action_velocity[:self.action_num]))
        buf.write(struct.pack('>%df' % self.action_num, *self.action_acceleration[:self.action_num]))
        buf.write(struct.pack('>%df' % self.action_num, *self.action_torque[:self.action_num]))

    @staticmethod
    def decode(data: bytes):
        if hasattr(data, 'read'):
            buf = data
        else:
            buf = BytesIO(data)
        if buf.read(8) != control_cmd_lcmt._get_packed_fingerprint():
            raise ValueError("Decode error")
        return control_cmd_lcmt._decode_one(buf)

    @staticmethod
    def _decode_one(buf):
        self = control_cmd_lcmt()
        self.action_type, self.action_num = struct.unpack(">Bi", buf.read(5))
        self.action_position = struct.unpack('>%df' % self.action_num, buf.read(self.action_num * 4))
        self.action_velocity = struct.unpack('>%df' % self.action_num, buf.read(self.action_num * 4))
        self.action_acceleration = struct.unpack('>%df' % self.action_num, buf.read(self.action_num * 4))
        self.action_torque = struct.unpack('>%df' % self.action_num, buf.read(self.action_num * 4))
        return self

    @staticmethod
    def _get_hash_recursive(parents):
        if control_cmd_lcmt in parents: return 0
        tmphash = (0xed637e7626ba0420) & 0xffffffffffffffff
        tmphash  = (((tmphash<<1)&0xffffffffffffffff) + (tmphash>>63)) & 0xffffffffffffffff
        return tmphash
    _packed_fingerprint = None

    @staticmethod
    def _get_packed_fingerprint():
        if control_cmd_lcmt._packed_fingerprint is None:
            control_cmd_lcmt._packed_fingerprint = struct.pack(">Q", control_cmd_lcmt._get_hash_recursive([]))
        return control_cmd_lcmt._packed_fingerprint

    def get_hash(self):
        """Get the LCM hash of the struct"""
        return struct.unpack(">Q", control_cmd_lcmt._get_packed_fingerprint())[0]

